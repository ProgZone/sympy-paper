% A description of some of the algorithms in SymPy. The list is not
% exhaustive.

% The sections here are preliminary. We may end up needing to cut some of
% this.

% XXX: Perhaps this should just be integrated into the features section.

\subsection{Numerics}

The \texttt{Float} class holds an arbitrary-precision binary floating-point value
and a precision in bits. An operation between two \texttt{Float}
inputs is rounded to the larger of the two precisions.

The preferred way to evaluate an expression numerically is with the
\texttt{evalf} method, which internally estimates the number of accurate
bits of the floating-point
approximation for each sub-expression, and adaptively increases the
working precision until the estimated accuracy of the
final result matches the sought number of decimal digits.

The internal error tracking does not provide rigorous error bounds
(in the sense of interval arithmetic) and cannot be used to track
uncertainty in measurement data in any meaningful way;
the sole purpose is to mitigate loss of accuracy that typically occurs
when converting symbolic expressions to numerical values, for example
due to catastrophic cancellation. This is illustrated by the following
example:

\begin{verbatim}
>>> cos(exp(-100)).evalf(25) - 1
0
>>> (cos(exp(-100)) - 1).evalf(25)
-6.919482633683687653243407e-88
\end{verbatim}

The numerical evaluation works with complex numbers and supports
more complicated expressions, such as
higher special functions, infinite series and integrals.

[todo: contrast with mathematica's significance arithmetic? cite Sofroniou2005precise, maybe Fateman]

\subsubsection{The mpmath library}

The implementation of arbitrary-precision floating-point arithmetic
is supplied by the mpmath library, which originally was developed
as a SymPy module but subsequently has been
moved to a standalone Python package.

Like SymPy, mpmath is a pure Python library.
Internally, mpmath represents a floating-point number
$(-1)^s x \cdot 2^y$ by a tuple $(s, x, y, b)$ where
$x$ and $y$ are arbitrary-size Python integers
and the redundant integer $b$ stores the bit length of $x$ for quick access.
If GMPY [citation?] is installed, mpmath automatically switches to
using the \texttt{gmpy.mpz} type for $x$ and using GMPY helper methods
to perform rounding-related operations, improving performance.

The mpmath library includes support for complex numbers, evaluation of
special functions, root-finding, linear algebra, polynomial approximation,
and numerical computation of limits, derivatives, integrals, infinite
series, and ODE solutions. All features work in arbitrary precision
and use algorithms that support computig hundreds of digits rapidly,
except in degenerate cases.

The double exponential (tanh-sinh) quadrature is used for numerical
integration by default. For smooth integrands, this algorithm usually
converges extremely rapidly, even when the integration interval is infinite
or singularities are present at the endpoints.
However, for good performance, singularities
in the middle of the interval must be specified
the user.
To evaluate slowly converging limits and infinite series, mpmath
automatically attempts to apply Richardson extrapolation and the
Shanks transformation (Euler-Maclaurin summation can also be used).
A function to evaluate oscillatory integrals by means of convergence
acceleration is also available.

A wide array of higher mathematical functions are implemented
with full support for complex values of all parameters and arguments,
including complete and incomplete gamma functions,
Bessel functions, orthogonal polynomials, elliptic functions and integrals,
zeta and polylogarithm functions,
the generalized hypergeometric function, and the Meijer G-function.

Most special functions are implemented as linear 
combinations of the generalized hypergeometric function ${}_pF_q$,
which is computed by a combination of direct summation,
argument transformations (for ${}_2F_1$, ${}_3F_2$, $\ldots$)
and asymptotic expansions
(for ${}_0F_1$, ${}_1F_1$, ${}_1F_2$, ${}_2F_2$, ${}_2F_3$)
to cover the whole complex domain.
Numerical integration and generic convergence acceleration
are also used in a few special cases.

In general, linear combinations and argument transformations
give rise to singularities that have to be removed for certain
combinations of parameters.
A good example is the modified Bessel function of the second kind
$$K_{\nu}(z) = \frac{1}{2} \left[
            \left(\frac{z}{2}\right)^{-\nu}
                \Gamma(\nu)
                {}_0F_1\left(1-\nu, \frac{z^2}{4}\right)
             -
             \left(\frac{z}{2}\right)^{\nu}
                 \frac{\pi}{\nu \sin(\pi \nu) \Gamma(\nu)}
                 {}_0F_1\left(\nu+1, \frac{z^2}{4}\right)
            \right]$$
where the limiting value $\lim_{\varepsilon \to 0} K_{n+\varepsilon}(z)$
has to be computed when $\nu = n$ is an integer.
A generic algorithm is used to evaluate
hypergeometric-type linear combinations of the above type.
The implementation automatically detects cancellation problems,
and computes limits numerically by perturbing parameters whenever
internal singularities occur (the perturbation size is automatically
decreased until the result is detected to converge numerically).

It is important for a computer algebra system
to support generalized hypergeometric functions and
Meijer G-functions robustly, due to their frequent appearance
in closed forms for integrals and sums.
Via mpmath, SymPy has relatively good support for evaluating sums and integrals
numerically, using two complementary approaches: direct numerical evaluation,
or first computing a symbolic closed form involving special functions. [example?]

\subsubsection{Numerical simplification}

The \texttt{nsimplify} method attempts to find a simple symbolic
expression that evaluates to the same numerical value as the given
input. It is a wrapper of the \texttt{identify} method in mpmath.
It works by applying a few simple transformations
(including square roots, reciprocals, logarithms and exponentials) to
the input and, for each transformed value,
using the PSLQ algorithm [CITATION NEEDED] to search for
a matching algebraic number or optionally a linear combination
of user-provided base constants (such as $\pi$).

\begin{verbatim}
>>> x = 1 / (sin(pi/5)+sin(2*pi/5)+sin(3*pi/5)+sin(4*pi/5))**2
>>> nsimplify(x)
-2*sqrt(5)/5 + 1
>>> nsimplify(pi, tolerance=0.01)
22/7
>>> nsimplify(1.783919626661888, [pi], tolerance=1e-12)
pi/(-1/3 + 2*pi/3)
\end{verbatim}

\subsection{Polynomials}

\subsection{The Risch Algorithm}
% Also the Meijer-G algorithm, if someone can write about it

\subsection{The Gruntz Algorithm}

\subsection{Logic}

\subsection{Other}
