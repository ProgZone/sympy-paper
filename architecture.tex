
%% I volunteer to write this section. --Aaron
%%
%% Representing symbolic expressions using Python objects

\subsection{The Core}

Every symbolic expression in SymPy is an instance of a Python class.
Expressions are represented by expression trees. The operators is represented
by the type of an expression and the child nodes are stored in the
\texttt{args} attribute. A leaf node in the expression tree has an empty
\texttt{args}.
The \texttt{args} attribute is provided by the class \texttt{Basic},
which is a superclass of all SymPy objects and
provides common methods to all SymPy tree-elements.
For example, take the expression $xy + 2$.

\begin{verbatim}
>>> from sympy import *
>>> x, y = symbols('x y')
>>> expr = x*y + 2
\end{verbatim}

The expression \texttt{expr} is an addition, so it is of type \texttt{Add}. The child
nodes of \texttt{expr} are \texttt{x*y} and \texttt{2}.

\begin{verbatim}
>>> type(expr)
<class 'sympy.core.add.Add'>
>>> expr.args
(2, x*y)
\end{verbatim}

We can dig further into the expression tree to see the full expression. For
example, the first child node, given by \texttt{expr.args[0]} is
\texttt{2}. Its class is \texttt{Integer}, and it has empty \texttt{args},
indicating that it is a leaf node

\begin{verbatim}
>>> expr.args[0]
2
>>> type(expr.args[0])
<class 'sympy.core.numbers.Integer'>
>>> expr.args[0].args
()
\end{verbatim}

The function \texttt{srepr} give a string representing a valid Python code,
containing all the nested class constructor calls to create the given expression:

\begin{verbatim}
>>> srepr(expr)
"Add(Mul(Symbol('x'), Symbol('y')), Integer(2))"
\end{verbatim}

Every SymPy expression satisfies a key invariant, namely,
\texttt{expr.func(*expr.args) == expr}. This means that expressions are
rebuildable from their \texttt{args}\footnote{\texttt{expr.func} is used
  instead of \texttt{type(expr)} to allow the function of an expression to be
  distinct from its actual Python class. In most cases the two are the same.}.
Here, we note that in SymPy, the \texttt{==} operator represents exact
structural equality, not mathematical equality. This allows us to test if any
two expressions are equal to one another as expression trees.

Python allows classes to overload operators. The Python interpreter translates
above \texttt{x*y + 2} to, roughly,
\verb|(x.__mul__(y)).__add__(2)|. \texttt{x} and \texttt{y}, returned from
the \texttt{symbols} function, are \texttt{Symbol} instances. The \texttt{2}
in the expression is processed by Python as a literal, and is stored as
Python's builtin \texttt{int} type. When \texttt{2} is called by the
\verb|__add__|, it is converted to the SymPy type \texttt{Integer(2)}. In
this way, SymPy expressions can be built in the natural way using Python
operators and numeric literals.

One must be careful in one particular instance. Python does not have a builtin
rational literal type. Given a fraction of integers in \texttt{1/2}, Python
will perform floating point division and produce \texttt{0.5}\footnote{This is
  the behavior in Python 3. In Python 2, \texttt{1/2} will perform integer
  division and produce \texttt{0}, unless one uses \texttt{from \_\_future\_\_
    import division}}. Because Python uses eager evaluation, expressions like
\texttt{x + 1/2} will produce \texttt{x + 0.5}, because by the time a SymPy
function sees the \texttt{1/2} it has already been converted to \texttt{0.5}
by Python. However, for a CAS like SymPy, we typically want to work with exact
rational numbers whenever possible. Working around this is simple, however:
one can wrap one of the integers with \texttt{Integer}, like \texttt{x +
  Integer(1)/2}, or using \texttt{x + Rational(1, 2)}. This gotcha is a small
downside to using Python directly instead of a custom DSL, and we consider it
to be worth it for the advantages listed above.

%%
%% Assumptions
\subsection{Assumptions}

A important feature of the SymPy core is the assumptions system. The
assumptions system allows users to specify that symbols have certain common
mathematical properties, such as being positive, imaginary, or integer. SymPy
is careful to never perform simplifications on an expression unless the
assumptions allow them. For instance, the identity $\sqrt{x^2} = x$ holds if
$x$ is nonnegative ($x>=0$). If $x$ is real, the identity $\sqrt{x^2}=|x|$
holds. However, for general complex $x$, no such identity holds.

By default, SymPy performs all calculations assuming that variables are
complex valued. This assumption makes it easier to treat mathematical problems
in full generality.

\begin{verbatim}
>>> x = Symbol('x')
>>> sqrt(x**2)
sqrt(x**2)
\end{verbatim}

By assuming symbols are complex by default, SymPy avoids performing
mathematically invalid operations. However, in many cases users will wish to
simplify expressions containing terms like $\sqrt{x^2}$.

Assumptions are set on \texttt{Symbol} objects when they are created. For
instance \texttt{Symbol('x', positive=True)} will create a symbol named
\texttt{x} that is assumed to be positive.

\begin{verbatim}
>>> x = Symbol('x', positive=True)
>>> sqrt(x**2)
x
\end{verbatim}

Some common assumptions that SymPy allows are \texttt{positive},
\texttt{negative}, \texttt{real}, \texttt{nonpositive}, \texttt{nonnegative},
\texttt{real}, \texttt{integer}, and \texttt{commutative}\footnote{If $A$ and
  $B$ are Symbols created with \texttt{commutative=False} then SymPy will keep
  $AB$ and $BA$ distinct.}. Assumptions on any object can be checked with the
\verb|is_|\texttt{\textit{assumption}} attribute.

Assumptions are needed only to restrict a domain so that certain
simplifications can be performed. It is not required to make the domain match
the input of a function. For instance, one can create the object
$\sum_{n=0}^m f(n)$ as \texttt{Sum(f(n), (n, 0, m))} without setting
\texttt{integer=True} when creating the Symbol object \texttt{n}.

The assumptions system additionally has deductive capabilities. The
assumptions use a three-valued logic using the Python builtin objects
\texttt{True}, \texttt{False}, and \texttt{None}. \texttt{None} represents the
``unknown'' case, meaning either the given assumption can be either true or
false under the given information, for instance, \verb|Symbol('x', real=True).is_real|
will give \texttt{None} because a real symbol might be
positive or it might not, or not enough is implemented to determine, for
instance, \verb|(pi + E).is_irrational| gives \texttt{None}, because SymPy
does not know how to determine if $\pi + e$ is rational or irrational.

Basic implications between the facts are used to deduce assumptions. For
instance, the assumptions system knows that being an integer implies being
rational, so \verb|Symbol('x', integer=True).is_rational| returns
\texttt{True}. Furthermore, expressions compute the assumptions on themselves
based on the assumptions of their arguments.

SymPy also has an experimental assumptions system where facts are stored
separate from objects, and deductions are made with a SAT solver. We will not
discuss this system here.

%%
%% Extensibility
\subsection{Extensibility}

%% Functions
\subsection{Functions}

Mathematical functions are implemented as Python classes.

%% Pattern matching
%%
%%%% three kinds of pattern matching in SymPy core.
%%%% `strategies` and `unify` modules also worth mentioning
%%%% (fu trig simplification function).
%%%% Rewriting rules.

%% Withheld evaluated (appears frequently on StackOverflow as a question).
