% Features to discuss in-depth:
This section gives a basic introduction of SymPy, and lists its features.
A few features---assumptions, simplification, calculus, polynomials, printers,
solvers, and matrices---are core components of SymPy and are discussed in
depth. Many other features are discussed in depth in the supplementary
material.

\subsection{Basic Usage}

% symbols, various ways to declare them

Symbolic variables, called symbols, must be defined and assigned to
Python variables before they can be used. This is typically done through the
\texttt{symbols} function, which may create multiple symbols in a single
function call. For instance,
\begin{verbatim}
>>> x, y, z = symbols('x y z')
\end{verbatim}
creates three symbols representing variables named $x$, $y$, and $z$. In this
particular instance, these symbols are all assigned to Python variables of the
same name. However, the user is free to assign them to different
Python variables, while representing the same symbol, such as
\texttt{a, b, c = symbols(\textquotesingle{}x y z\textquotesingle{})}.
In order to minimize potential confusion, though, all examples in this paper will
assume that
the symbols \verb|x|, \verb|y|, and \verb|z| have been assigned to Python variables
identical to their symbolic names.

Expressions are created from symbols using Python's mathematical syntax.  For
instance, the following Python code creates the expression $(x^2 - 2x + 3)/y$.
Note that the expression remains unevaluated: it is represented symbolically.

\begin{verbatim}
>>> (x**2 - 2*x + 3)/y
(x**2 - 2*x + 3)/y
\end{verbatim}

Importantly, SymPy expressions are immutable. This simplifies the design of
SymPy by allowing expression interning. It also enables expressions to be
hashed, that is used to implement caching in SymPy.

\subsection{List of Features}

Although SymPy's extensive feature set cannot be covered in-depth in this
paper, calculus and other bedrock areas are discussed in their own
subsections. Additionally, Table~\ref{features-table} gives a compact listing
of all major capabilities present in the SymPy codebase. This grants a
sampling from the breadth of topics and application domains that SymPy
services. Unless stated otherwise, all features noted in
Table~\ref{features-table} are symbolic in nature. Numeric features are
discussed in Section~\ref{sec:numerics}.

\begin{longtable}[htbc]{>{\raggedright}p{0.30\linewidth}p{0.63\linewidth}}
\caption{SymPy Features and Descriptions\label{features-table}}\\
\toprule
\textbf{Feature (submodules)} & \textbf{Description} \\
\midrule
Calculus (\texttt{sympy.core}, \texttt{sympy.series}, \texttt{sympy.integrals}) & Algorithms for computing derivatives, integrals, and limits.\\

Category Theory (\texttt{sympy.categories}) & Representation of objects, morphisms, and diagrams. Tools
for drawing diagrams with Xy-pic.\\

Code Generation (\texttt{sympy.printing}, \texttt{sympy.codegen}) & Generation of compilable and executable code in a
variety of different programming languages from expressions directly. Target
languages include C, Fortran, Julia, JavaScript,
Mathematica, MATLAB and Octave, Python, and Theano.\\

Combinatorics \& Group Theory (\texttt{sympy.combinatorics}) & Permutations, combinations,
partitions, subsets, various permutation groups (such as polyhedral, Rubik,
symmetric, and others), Gray codes~\cite{Nijenhuis1978combinatorial},
and Prufer sequences~\cite{biggs1976graph}.\\

Concrete Math (\texttt{sympy.concrete}) & Summation, products, tools for determining whether summation
and product expressions are convergent, absolutely convergent, hypergeometric,
and for determining other properties; computation of Gosper's normal form~\cite{petkovvsek1996bak} for two univariate polynomials.\\

Cryptography (\texttt{sympy.crypto}) & Block and stream ciphers, including shift, Affine,
substitution, Vigen\`{e}re's, Hill's, bifid, RSA, Kid RSA,
linear-feedback shift registers, and Elgamal encryption.\\

Differential Geometry (\texttt{sympy.diffgeom}) & Representations of manifolds, metrics, tensor
products, and coordinate systems in Riemannian and pseudo-Riemannian
geometries~\cite{FunctionalDifferentialGeometry}.\\
% TODO: Someone verify that this is a good summary of the diffgeom module

Geometry (\texttt{sympy.geometry}) & Representations of 2D geometrical entities, such as lines and
circles. Enables queries on these entities, such as asking the area of an
ellipse, checking for collinearity of a set of
points, or finding the intersection between objects.\\

Lie Algebras (\texttt{sympy.liealgebras}) & Representations of Lie algebras and root systems.\\

Logic (\texttt{sympy.logic}) & Boolean expressions, equivalence testing, satisfiability, and normal
forms.\\

Matrices (\texttt{sympy.matrices}) & Tools for creating matrices of symbols and expressions.
Both sparse and dense representations, as well as symbolic linear
algebraic operations (e.g., inversion and factorization), are
supported.\\

Matrix Expressions (\texttt{sympy.matrices.expressions}) & Matrices with symbolic dimensions (unspecified entries).
Block matrices.\\

Number Theory (\texttt{sympy.ntheory}) & Prime number generation, primality testing, integer
factorization, continued fractions, Egyptian fractions, modular arithmetic,
quadratic residues, partitions, binomial and multinomial coefficients,
prime number tools, hexidecimal digits of $\pi$, and integer factorization. \\

Plotting (\texttt{sympy.plotting}) & Hooks for visualizing expressions via matplotlib~\cite{Hunter:2007}
or as text drawings when lacking a graphical back-end. 2D function plotting,
3D function
plotting, and 2D implicit function plotting are supported.\\

Polynomials (\texttt{sympy.polys}) & Polynomial algebras over various coefficient domains.
Functionality ranges from simple operations (e.g., polynomial division) to
advanced computations (e.g., Gr\"obner bases~\cite{adams1994introduction} and multivariate
factorization over algebraic number domains).\\

Printing (\texttt{sympy.printing}) & Functions for printing SymPy expressions in the terminal with ASCII
or Unicode characters and converting SymPy expressions to \LaTeX{} and
MathML.\\

Quantum Mechanics (\texttt{sympy.physics.quantum}) & Quantum states, bra--ket notation, operators, basis sets,
representations, tensor products, inner products, outer products, commutators,
anticommutators, and specific quantum system implementations.\\

Series (\texttt{sympy.series}) & Series expansion, sequences, and limits of sequences.
This includes Taylor, Laurent, and Puiseux series as well as special series, such
as Fourier and formal power series.\\

Sets (\texttt{sympy.sets}) & Representations of empty, finite, and infinite sets (including
special sets such as the natural, integer, and complex numbers). Operations
on sets such as union, intersection, Cartesian product, and building sets from
other sets are supported.\\

Simplification (\texttt{sympy.simplify}) & Functions for manipulating and simplifying expressions.
Includes algorithms for simplifying hypergeometric functions, trigonometric
expressions, rational functions, combinatorial functions, square root
denesting, and common subexpression elimination.\\

Solvers (\texttt{sympy.solvers}) & Functions for symbolically solving equations, systems
of equations, both linear and non-linear, inequalities, ordinary differential
equations, partial differential equations, Diophantine equations, and
recurrence relations.\\

Special Functions (\texttt{sympy.functions}) & Implementations of a number of well known special functions,
including Dirac delta, Gamma, Beta, Gauss error functions, Fresnel integrals,
Exponential integrals, Logarithmic integrals, Trigonometric integrals, Bessel,
Hankel, Airy, B-spline, Riemann Zeta, Dirichlet eta, polylogarithm, Lerch
transcendent, hypergeometric, elliptic integrals, Mathieu, Jacobi polynomials,
Gegenbauer polynomial, Chebyshev polynomial, Legendre polynomial, Hermite
polynomial, Laguerre polynomial, and
spherical harmonic functions.\\

Statistics (\texttt{sympy.stats}) & Support for a random variable type as well as the ability to
declare this variable from prebuilt distribution functions such as
Normal, Exponential, Coin, Die, and other custom distributions~\cite{StatsMRocklin}.\\

Tensors (\texttt{sympy.tensor}) & Symbolic manipulation of indexed objects.\\

Vectors (\texttt{sympy.vector}) & Basic operations on vectors and differential calculus with respect
to 3D Cartesian coordinate systems.\\
\bottomrule

\end{longtable}

%% Assumptions
\subsection{Assumptions}
\label{sec:assumptions}

SymPy performs logical inference through its assumptions system. The
assumptions system allows users to specify that symbols have certain common
mathematical properties, such as being positive, imaginary, or integral. SymPy
is careful to never perform simplifications on an expression unless the
assumptions allow them. For instance, the identity $\sqrt{t^2} = t$ holds if
$t$ is nonnegative ($t\ge 0$). However, for general complex $t$, no
such identity holds.

By default, SymPy performs all calculations assuming that symbols are
complex valued. This assumption makes it easier to treat mathematical problems
in full generality.
\begin{verbatim}
>>> t = Symbol('t')
>>> sqrt(t**2)
sqrt(t**2)
\end{verbatim}

By assuming the most general case, that \texttt{t} is complex by default, SymPy
avoids performing mathematically invalid operations. However, in many cases
users will wish to simplify expressions containing terms like $\sqrt{t^2}$.

Assumptions are set on \texttt{Symbol} objects when they are created. For
instance \texttt{Symbol(\textquotesingle{}t\textquotesingle{}, positive=True)} will create a symbol named
\texttt{t} that is assumed to be positive.
\begin{verbatim}
>>> t = Symbol('t', positive=True)
>>> sqrt(t**2)
t
\end{verbatim}

Some of the common assumptions that SymPy allows are \texttt{positive},
\texttt{negative}, \texttt{real}, \texttt{nonpositive}, \texttt{integer},
\texttt{prime} and \texttt{commutative}.\footnote{SymPy assumes that two
  expressions $A$ and $B$ commute with each other multiplicatively, that is,
  $A\cdot B=B\cdot A$, unless they both have \texttt{commutative=False}. Many
  algorithms in SymPy require special consideration to work correctly with
  noncommutative products.} Assumptions on any object can be checked with the
\verb|is_|\texttt{\textit{assumption}} attributes, like \verb|t.is_positive|.

Assumptions are only needed to restrict a domain so that certain
simplifications can be performed. They are not required to make the domain match
the input of a function. For instance, one can create the object
$\sum_{n=0}^m f(n)$ as \verb|Sum(f(n), (n, 0, m))| without setting
\texttt{integer=True} when creating the Symbol object \texttt{n}.

The assumptions system additionally has deductive capabilities. The
assumptions use a three-valued logic using the Python built in objects
\texttt{True}, \texttt{False}, and \texttt{None}. Note that \texttt{False}
is returned if the SymPy object doesn't or can't have the assumption.
For example, both \texttt{I.is\_real} and \texttt{I.is\_prime} return
\texttt{False} for the imaginary unit \texttt{I}.

\texttt{None} represents the
``unknown'' case. This could mean that given assumptions do not unambiguously
specify the truth of an attribute. For instance,
\texttt{Symbol(\textquotesingle{}x\textquotesingle{}, real=True).is\_positive}
will give \texttt{None} because a real symbol might be positive or negative.
The \texttt{None} could also mean that not enough is known or implemented to
compute the given fact. For instance, \texttt{(pi + E).is\_irrational} gives
\texttt{None}---indeed, determining whether $\pi + e$ is rational or irrational
is an open problem in mathematics~\cite{lang1966introduction}.

Basic implications between the facts are used to deduce assumptions. For
instance, the assumptions system knows that being an integer implies being
rational.
\begin{verbatim}
>>> i = Symbol('i', integer=True)
>>> i.is_rational
True
\end{verbatim}
Furthermore, expressions compute the assumptions on themselves
based on the assumptions of their arguments. For instance, if \texttt{x} and
\texttt{y} are both created with \texttt{positive=True}, then
\texttt{(x + y).is\_positive} will be \texttt{True} whereas
\texttt{(x - y).is\_positive} will be \texttt{None}.

\subsection{Simplification}

\input{simplification}

\subsection{Calculus}
\label{sec:calculus}
\input{calculus}

\subsection{Polynomials}
\input{polys}

\subsection{Printers}

\input{printers.tex}

% Solvers (regular equations, maybe also mention other types of solvers like ODEs/recurrence/Diophantine)
\subsection{Solvers}
\input{solvers.tex}

% Matrices (worth emphasizing that they are symbolic)
\subsection{Matrices}

\input{matrices}
