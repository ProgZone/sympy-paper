SymPy supports matrices with symbolic expressions as elements. There are two
types of matrices, Mutable and Immutable. Mutable classes are the default in
SymPy as mutability is important for performance, but it means that standard
matrices can not interact well with the rest of SymPy. This is because the
Basic object, from which most SymPy classes inherit, is immutable.

Immutable matrix classes inherit from Basic and can thus interact more
naturally with the rest of SymPy.

\begin{verbatim}
>>> x, y = symbols('x y')
>>> A = Matrix(2, 2, [x, x + y, y, x])
>>> A
Matrix([
[    x, x + y],
[    y,     x]])
\end{verbatim}

All SymPy matrix types can do linear algebra including matrix addition,
multiplication, exponentiation, computing determinant, solving linear systems
and computing inverses using LU decomposition, LDL decomposition, Gauss-Jordan
elimination, Cholesky decomposition, Moore-Penrose pseudoinverse, and adjugate
matrix.

All operations are computed are computed symbolically. Eigenvalues are
computed by generating the characteristic polynomial using the Berkowitz
algorithm and then solving it using polynomial routines. Diagonalizable
matrices can be diagonalized first to compute the eigenvalues.

\begin{verbatim}
>>> A.eigenvals()
{x - sqrt(y*(x + y)): 1, x + sqrt(y*(x + y)): 1}
\end{verbatim}

Internally these matrices store the elements as a list making it a dense
representation. For storing sparse matrices, the SparseMatrix and
ImmutableSparseMatrix classes can be used. Sparse matrix classes store
the elements in Dictionary of Keys (DoK) format.

SymPy also supports matrices with symbolic dimension values. MatrixSymbol
represents a matrix with dimensions $m\times n$, where $m$ and $n$ can be
symbolic. Matrix addition and multiplication, scalar operations, matrix
inverse and transpose are stored symbolically as matrix expressions. Mutable
matrices are converted to corresponding immutable types before interacting
with matrix expressions

\begin{verbatim}
>>> m, n, p = symbols("m, n, p", integer=True)
>>> R, S, T = MatrixSymbol("R", m, n), MatrixSymbol("S", n, p), MatrixSymbol("t", m, p)
>>> U = R*S + 2*T
>>> u.shape
(m, p)
>>> U[0, 1]
2*T[0, 1] + Sum(R[0, _k]*S[_k, 1], (_k, 0, n - 1))
\end{verbatim}

Block matrices are also supported in SymPy. BlockMatrix elements can be
any matrix expression which includes immutable matrices, matrix symbols and
block matrices. All functionalities of matrix expressions are also present in
BlockMatrix.


\begin{verbatim}
>>> n, m, l = symbols('n m l')
>>> X = MatrixSymbol('X', n, n)
>>> Y = MatrixSymbol('Y', m ,m)
>>> Z = MatrixSymbol('Z', n, m)
>>> B = BlockMatrix([[X, Z], [ZeroMatrix(m,n), Y]])
>>> print(B)
Matrix([
[X, Z],
[0, Y]])
>>> print(B[0, 0])
X[0, 0]
\end{verbatim}
