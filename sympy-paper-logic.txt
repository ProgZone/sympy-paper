Logic module
============

SymPy symbols can be used as propositional variables and can be
substituted as `true` or `false`. Good number of manipulation
features have been implemented in the SymPy Logic module.

Constructing boolean expressions
--------------------------------

A boolean variable can be declared as a SymPy symbol. Python
operators `&`, `|`, `~`, `^`, `>>`, `<<` are overloaded for 
logical `And`, `Or`, negation, `Xor`, right implication and 
left implication respectively.
You can also directly call the functions `And()`, `Or()`, Not(),
`Xor()`, `Nand()`, `Nor()`, `Implies`, `Equivalent` and `ITE` for
constructing corresponding expressions.

These boolean symbols can be substituted `True` or `False` 
using `.subs()`

Example:
>>> (y & x).subs({x: True, y: True})
True

SOPform and POSform
-------------------

SOPform function implemented in this module can be fed with 
a set of variables, minterms and don't cares and it returns 
the minimized boolean function in SOPform. Quine–McCluskey 
algorithm is used which is functionally identical to Karnaugh
mapping. A similar function, POSform, can be used to return 
the result in POS form.  


CNF and DNF
-----------

Functions `to_cnf()`, `to_dnf()` and `to_nnf()` convert the
expression fed to Conjunctive Normal Form, Disjunctive Normal
Form and Negation Normal Form respectively. Functions `is_cnf()`,
`is_dnf()`, `is_nnf()` checks if an expression is in the given 
form.

Simplification and Equivalence
------------------------------

`simplify_logic` can be used to return the expression in a
simplified form. `bool_map` is used to return correspondence 
between the variables of two expressions so as to represent the 
same logical behaviour. This returns false if not possible.

SAT solving
-----------

Function `satisfiable` is used to check the satisfiability of
a boolean expression. Returns the model if satisfiable, returns
False otherwise.

Parameters:

expr: The expression to check for satisfiability.
algorithm: Internal algorithm to be used. Current options in 
	SymPy are 'dpll' and 'dpll2', to be explained in following
	sections.
all_models: On setting all_models to True, if given expr is 
	satisfiable then it returns a generator of models. However, 
	if expr is unsatisfiable then it returns a generator containing 
	the single element False.


# Knowledge Base needed? I feel it's not necessary (even entails).

Algorithms for SAT solving
--------------------------
`dpll`
------
Has basic DPLL implementation with DP kernalization, branching
and backtracking.
- http://en.wikipedia.org/wiki/DPLL_algorithm
- https://www.researchgate.net/publication/242384772_Implementations_of_the_DPLL_Algorithm

`dpll2`
-------
Has the following features
  - Clause learning
  - Watch literal scheme
  - VSIDS heuristic

Clause learning: Reaching a conflict clause results in "learning" the root causes 
(assignments to variables) of the conflict in order to avoid reaching the same conflict later.
- J.P. Marques-Silva and Karem A. Sakallah (November 1996). "GRASP-A New Search Algorithm for Satisfiability". Digest of IEEE International Conference on Computer-Aided Design (ICCAD). pp. 220–227.
- J.P. Marques-Silva and Karem A. Sakallah (May 1999). "GRASP: A Search Algorithm for Propositional Satisfiability" (PDF). IEEE Transactions on Computers 48 (5): 506–521. doi:10.1109/12.769433.
- Roberto J. Bayardo Jr. and Robert C. Schrag (1997). "Using CSP look-back techniques to solve real world SAT instances" (PDF). Proc. 14th Nat. Conf. on Artificial Intelligence (AAAI). pp. 203–208.

Watch literal scheme and VSIDS heuristics:
- http://www.google.co.in/patents/US7418369
- @misc{moskewicz2008method,
  title={Method and system for efficient implementation of boolean satisfiability},
  author={Moskewicz, M. and Madigan, C. and Malik, S.},
  url={http://www.google.co.in/patents/US7418369},
  year={2008},
  month=aug # "~26",
  publisher={Google Patents},
  note={US Patent 7,418,369}
}
